import os
import glob
import re

def fix_block_math():
    posts_dir = os.path.join("content", "posts")
    files = glob.glob(os.path.join(posts_dir, "*.md"))
    
    print(f"Scanning {len(files)} files for inline block math '$$' usage...\n")
    
    for file_path in files:
        with open(file_path, 'r', encoding='utf-8') as f:
            content = f.read()
            
        original_content = content
        
        # Heuristic Pattern:
        # We want to find $$ that is NOT surrounded by newlines.
        # Case 1: Text $$ Math $$ (Inline usage of block delimiter -> Bad for auto-render?)
        # Actually auto-render often treats $$...$$ as specific display mode, but usually requires it to be block-level or config "displayMode: true".
        # The issue observed: "$$\mathcal{L} ... $$" text surrounding it prevented it from rendering?
        # Browser said: "delimiters are placed on the same line as the preceding text."
        
        # Regex to ensure $$ starts on a new line (or after a char that isn't a newline)
        # We want to transform:
        # "Some text $$ Math $$ Some text"
        # to:
        # "Some text\n\n$$ Math $$\n\nSome text"
        
        # Be careful not to break existing correct blocks.
        
        # Strategy:
        # Replace `(\S)[ \t]*\$\$` with `\1\n\n$$` (Text before)
        # Replace `\$\$[ \t]*(\S)` with `$$\n\n\1` (Text after) -- Wait, standard block is usually content inside.
        
        # Let's assume content inside $$...$$ is fine on one line.
        # We just need the delimiters themselves to be separated from OUTSIDE context.
        
        # 1. Ensure newline BEFORE opening $$ 
        # Look for non-newline char valid char, then space, then $$.
        # Excluding cases where it's already on newline.
        # Note: we need to handle the closing $$ too.
        # But wait, `$$ x^2 $$` is valid block math.
        
        # Let's try a regex that finds `$$` pairs and checks boundaries.
        
        def replacer(match):
            full_match = match.group(0)
            # Check if it's already well formatted?
            # It's hard to be perfect.
            # Let's just create newlines around the whole block.
            
            # Identify the block: match `$$` ... `$$`
            return f"\n\n{full_match.strip()}\n\n"

        # Regex: `\$\$[\s\S]*?\$\$` (non greedy match of block)
        # But we only want to touch those that are "inline" looking.
        # Actually, simply ensuring "\n\n" around ANY `$$...$$` block is usually safe for Markdown blocks.
        
        new_content = re.sub(r'\$\$([\s\S]*?)\$\$', lambda m: f"\n\n$${m.group(1)}$$\n\n", content)
        
        # Clean up excessive newlines (e.g. \n\n\n\n) generated by this
        new_content = re.sub(r'\n{3,}', '\n\n', new_content)
        
        if new_content != original_content:
            with open(file_path, 'w', encoding='utf-8') as f:
                f.write(new_content)
            print(f"Fixed block math in: {os.path.basename(file_path)}")

if __name__ == "__main__":
    fix_block_math()
